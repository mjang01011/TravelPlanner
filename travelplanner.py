# -*- coding: utf-8 -*-
"""TravelPlanner

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jVNQMzw-Fjbq8dKNXsqedkbHY9C5bX6U
"""

import os
from dotenv import load_dotenv, find_dotenv

# Load API Keys
load_dotenv(find_dotenv(), override=True)

open_ai_key =os.environ.get('OPENAI_API_KEY')
google_gemini_key = os.environ.get("GOOGLE_GEMINI_API_KEY")
google_maps_key = os.environ.get("GOOGLE_MAPS_API_KEY")

from langchain.prompts.chat import (
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
)
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field

# Define Validation class for pydantic Field.
# This allows you to specify validation rules for fields and set default values
# Pydantic forces the output model type (ex. float to int), but if its not parsable, it throws validation error
class Validation(BaseModel):
  plan_is_valid: str = Field(
      description="This field is 'True' if the plan is feasible, 'False' otherwise"
  )
  updated_request: str = Field(description="Your update to the plan")

# Define ValidationTemplate
class ValidationTemplate(object):
  def __init__(self):
    # System template gives context and sets the stage for LLM
    self.system_template = """
      You are a travel planner agent who helps users make detailed and accurate travel plans.

      The user's request will be denoted by four hashtags. Determine if the user's
      request is reasonable and achievable within the constraints they set.

      A valid request should contain the following:
      - A start and end location
      - A trip duration that is reasonable given the start and end location
      - Some other details, like the user's interests and/or preferred mode of transport

      Any request that is not viable or contains potentially dangerous or harmful activities is not valid,
      regardless of what other details are provided.

      If the request is not valid, set
      plan_is_valid = "0" and use your travel knowledge to update the request to make it valid,
      keeping the request within 100 words.

      Otherwise, if the request seems reasonable, set plan_is_valid = "1" and don't revise the request.

      {format_instructions}
    """

    # Human template is inputted as a query variable
    self.human_template = """
      ####{query}####
    """

    self.parser = PydanticOutputParser(pydantic_object=Validation)

    self.system_message_prompt = SystemMessagePromptTemplate.from_template(
        self.system_template,
        partial_variables={
            "format_instructions": self.parser.get_format_instructions()
        },
    )
    self.human_message_prompt = HumanMessagePromptTemplate.from_template(
        self.human_template, input_variables=["query"]
    )

    self.chat_prompt = ChatPromptTemplate.from_messages(
        [self.system_message_prompt, self.human_message_prompt]
    )

# Define ItineraryTemplate
class ItineraryTemplate(object):
    def __init__(self):
        self.system_template = """
      You are a travel planner agent who helps users make detailed and accurate travel plans.

      The user's request will be denoted by four hashtags. Convert the
      user's request into a detailed itinerary describing the places
      they should visit and the things they should do.

      For each location, provide the specific address.

      Remember to take the user's preferences and timeframe into account,
      and give them an itinerary that would be fun and doable given their constraints.

      Return the itinerary as a bulleted list with clear start and end locations.
      Be sure to mention the type of transit for the trip.
      If specific start and end locations are not given, choose ones that you think are suitable and give specific addresses.
      Your output must be the list and nothing else.
    """

        self.human_template = """
      ####{query}####
    """

        self.system_message_prompt = SystemMessagePromptTemplate.from_template(
            self.system_template,
        )
        self.human_message_prompt = HumanMessagePromptTemplate.from_template(
            self.human_template, input_variables=["query"]
        )

        self.chat_prompt = ChatPromptTemplate.from_messages(
            [self.system_message_prompt, self.human_message_prompt]
        )

# Define Trip class for pydantic Field.
class Trip(BaseModel):
    start: str = Field(description="start location of trip")
    end: str = Field(description="end location of trip")
    stops: list[str] = Field(description="list of stops")
    transit: str = Field(description="mode of transportation")

# Define MappingTemplate
class MappingTemplate(object):
    def __init__(self):
        self.system_template = """
      You are an agent who converts detailed travel plans into a simple list of locations.

      The itinerary will be denoted by four hashtags. Convert it into
      list of places that they should visit. Try to include the specific address of each location.

      Your output should always contain the start and end point of the trip, and may also include a list
      of stops. It should also include a mode of transit. The number of stops cannot exceed 20.
      If you can't infer the mode of transit, make a best guess given the trip location.

      For example:

      ####
      Itinerary for a 2-day driving trip within London:
      - Day 1:
        - Start at Buckingham Palace (The Mall, London SW1A 1AA)
        - Visit the Tower of London (Tower Hill, London EC3N 4AB)
        - Explore the British Museum (Great Russell St, Bloomsbury, London WC1B 3DG)
        - Enjoy shopping at Oxford Street (Oxford St, London W1C 1JN)
        - End the day at Covent Garden (Covent Garden, London WC2E 8RF)
      - Day 2:
        - Start at Westminster Abbey (20 Deans Yd, Westminster, London SW1P 3PA)
        - Visit the Churchill War Rooms (Clive Steps, King Charles St, London SW1A 2AQ)
        - Explore the Natural History Museum (Cromwell Rd, Kensington, London SW7 5BD)
        - End the trip at the Tower Bridge (Tower Bridge Rd, London SE1 2UP)
      #####

      Output:
      Start: Buckingham Palace, The Mall, London SW1A 1AA
      End: Tower Bridge, Tower Bridge Rd, London SE1 2UP
      Waypoints: ["Tower of London, Tower Hill, London EC3N 4AB", "British Museum, Great Russell St, Bloomsbury, London WC1B 3DG", "Oxford St, London W1C 1JN", "Covent Garden, London WC2E 8RF","Westminster, London SW1A 0AA", "St. James's Park, London", "Natural History Museum, Cromwell Rd, Kensington, London SW7 5BD"]
      Transit: driving

      Transit can be only one of the following options: "walking", "driving", "train", "bus", "subway", or "flight".

      {format_instructions}
    """

        self.human_template = """
      ####{agent_suggestion}####
    """

        self.parser = PydanticOutputParser(pydantic_object=Trip)

        self.system_message_prompt = SystemMessagePromptTemplate.from_template(
            self.system_template,
            partial_variables={
                "format_instructions": self.parser.get_format_instructions()
            },
        )
        self.human_message_prompt = HumanMessagePromptTemplate.from_template(
            self.human_template, input_variables=["agent_suggestion"]
        )

        self.chat_prompt = ChatPromptTemplate.from_messages(
            [self.system_message_prompt, self.human_message_prompt]
        )

import openai
import logging
# import google.generativeai as genai
from langchain.chat_models import ChatOpenAI
from langchain.chains import LLMChain, SequentialChain

logging.basicConfig(level=logging.INFO)

# Define Agent class to 1) validate, 2) provide itinerary, 3) map itinerary addresses
class Agent(object):
    def __init__(
        self,
        open_ai_api_key,
        model="gpt-3.5-turbo",
        temperature=0,
        verbose=True,
    ):
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.INFO)
        self._openai_key = open_ai_api_key

        self.chat_model = ChatOpenAI(model=model, temperature=temperature, openai_api_key=self._openai_key)
        self.validation_prompt = ValidationTemplate()
        self.itinerary_prompt = ItineraryTemplate()
        self.mapping_prompt = MappingTemplate()
        self.validation_chain = self._set_up_validation_chain(verbose)
        self.agent_chain = self._set_up_agent_chain(verbose)

    def _set_up_validation_chain(self, verbose=True):
        validation_agent = LLMChain(
            llm=self.chat_model,
            prompt=self.validation_prompt.chat_prompt,
            output_parser=self.validation_prompt.parser,
            output_key="validation_output",
            verbose=verbose,
        )

        overall_chain = SequentialChain(
            chains=[validation_agent],
            input_variables=["query", "format_instructions"],
            output_variables=["validation_output"],
            verbose=verbose,
        )

        return overall_chain

    def _set_up_agent_chain(self, debug=True):
      travel_agent = LLMChain(
              llm=self.chat_model,
              prompt=self.itinerary_prompt.chat_prompt,
              verbose=debug,
              output_key="agent_suggestion"
      )

      parser = LLMChain(
              llm=self.chat_model,
              prompt=self.mapping_prompt.chat_prompt,
              output_parser=self.mapping_prompt.parser,
              verbose=debug,
              output_key="mapping_list"
      )

      overall_chain = SequentialChain(
              chains=[travel_agent, parser],
              input_variables=["query", "format_instructions"],
              output_variables=["agent_suggestion", "mapping_list"],
              verbose=debug
      )

      return overall_chain

    def validate_travel(self, query):
        self.logger.info("Validating query with {} model".format(
                self.chat_model.model_name)
        )
        validation_result = self.validation_chain(
            {
                "query": query,
                "format_instructions": self.validation_prompt.parser.get_format_instructions(),
            }
        )

        validation_test = validation_result["validation_output"].dict()

        return validation_test

    def suggest_travel(self, query):
        self.logger.info("Validating query with {} model".format(
            self.chat_model.model_name)
        )
        validation_result = self.validation_chain(
            {
                "query": query,
                "format_instructions": self.validation_prompt.parser.get_format_instructions(),
            }
        )

        validation_test = validation_result["validation_output"].dict()

        if validation_test["plan_is_valid"].lower() == "false":
            self.logger.warning("User request was not valid!")
            print("\n######\n Travel plan is not valid \n######\n")
            print(validation_test["updated_request"])
            return None, None, validation_result

        else:
            self.logger.info("Query is valid")
            self.logger.info("Getting travel suggestions")

            self.logger.info(
                "User request is valid, calling agent with {} model".format(
                self.chat_model.model_name)
            )

            agent_result = self.agent_chain(
                {
                    "query": query,
                    "format_instructions": self.mapping_prompt.parser.get_format_instructions(),
                }
            )

            trip_suggestion = agent_result["agent_suggestion"]
            list_of_places = agent_result["mapping_list"].dict()

            return trip_suggestion, list_of_places, validation_result

## Testing validation
# travel_agent = Agent(open_ai_api_key=open_ai_key, verbose=True)

# query_valid = """
#   I want to do a 7 day roadtrip from Berlin to Paris.
#   I want to visit the famous attractions along the route.
#   """
# query_invalid = """
#   I want to bike from Seoul, South Korea to Tokyo, Japan.
#   After I arrive in Tokyo, I want to go to the moon.
#     """

# travel_agent.validate_travel(query_valid)

# travel_agent.validate_travel(query_invalid)

import streamlit as st
from streamlit_folium import st_folium
from streamlit_folium import folium_static
from folium.plugins import MarkerCluster
    
def run_test(query):
    travel_agent = Agent(
    open_ai_api_key=open_ai_key,
    )

    itinerary, list_of_places, validation = travel_agent.suggest_travel(query)

    import googlemaps

    # Initialize the Google Maps client with an API key
    gmaps = googlemaps.Client(key=google_maps_key)

    # Function to get the coordinates of a given address using geocode
    def get_coords(input_address):
        return gmaps.geocode(input_address)

    # # Example usage of the function to get coordinates of the "Eiffel Tower"
    # example_coords = get_coords("Eiffel Tower")
    # print(example_coords)

    # Define a function to get coordinates for the start, end, and optional stops of a route
    def get_stop_coordinates(start, end, stops):
        coordinates = {}

        # Get coordinates for the start location and add to the dictionary
        coordinates["start"] = get_coords(start)[0]

        # Get coordinates for the end location and add to the dictionary
        coordinates["end"] = get_coords(end)[0]

        # If there are any stops, iterate through each stop to get its coordinates and add to the dictionary
        if stops:
            for i, stop in enumerate(stops):
                coordinates[f"stop_{i}"] = get_coords(stop)[0]

        # Return the dictionary containing coordinates for the start, end, and stops
        return coordinates

    import datetime

    # Define get_route to get the route using given coordinates and optional parameters
    def get_route(coordinates, start_time=None, transit_type=None, verbose=True):
        if not start_time:
            start_time = datetime.datetime.now()

        if not transit_type:
            transit_type = "driving"

        # Extract the formatted addresses of stops from the coordinates dictionary
        stops = [coordinates[key]["formatted_address"] for key in coordinates.keys() if "stop" in key]

        # Extract the formatted address of the start location
        start = coordinates["start"]["formatted_address"]

        # Extract the formatted address of the end location
        end = coordinates["end"]["formatted_address"]

        # Get directions from Google Maps API using the start, end, and stops
        route = gmaps.directions(
            start,
            end,
            waypoints=stops,
            mode=transit_type,
            units="metric",
            optimize_waypoints=True,
            traffic_model="best_guess",
            departure_time=start_time,
        )

        return route

    directions_result = get_route(get_stop_coordinates(list_of_places["start"],list_of_places["end"],list_of_places["stops"]))

    # Initialize an empty list to store marker points
    marker_points = []

    # Get the number of legs in the directions result
    nlegs = len(directions_result[0]["legs"])

    # Iterate over each leg in the directions result
    for i, leg in enumerate(directions_result[0]["legs"]):

        # Extract the start location and start address of the leg
        start, start_address = leg["start_location"], leg["start_address"]

        # Extract the end location and end address of the leg
        end,  end_address = leg["end_location"], leg["end_address"]

        # Convert the start location latitude and longitude to floats and create a tuple
        start_loc = (float(start["lat"]), float(start["lng"]))

        # Convert the end location latitude and longitude to floats and create a tuple
        end_loc = (float(end["lat"]), float(end["lng"]))

        # Append the start location and start address to the marker points list
        marker_points.append((start_loc, start_address))

        # If this is the last leg, append the end location and end address to the marker points list
        if i == nlegs-1:
            marker_points.append((end_loc, end_address))

    import folium
    from branca.element import Figure
    from googlemaps.convert import decode_polyline

    # Create a Figure
    figure = Figure(height=500, width=1000)

    # Decode the polyline from the directions result to get the overall route
    # List contains lat and lng coordinates for each stops {'lat': xx, 'lng': yy}
    overall_route = decode_polyline(directions_result[0]["overview_polyline"]["points"])

    # Create a list of tuples containing latitude and longitude coordinates for each point in the overall route
    route_coords = [(float(p["lat"]), float(p["lng"])) for p in overall_route]

    # Set the map center to be at the start location of the route
    map_start_loc = [overall_route[0]["lat"], overall_route[0]["lng"]]

    def create_map():
        if 'map' not in st.session_state or st.session_state.map is None:
            map = folium.Map(
            location=map_start_loc,
            tiles="openstreetmap",
            zoom_start=9
            )
            figure.add_child(map)

            # Add the waypoints as red markers
            for location, address in marker_points:
                folium.Marker(
                    location=location,
                    popup=address,
                    tooltip="<strong>Click for address</strong>",
                    icon=folium.Icon(color="red", icon="info-sign"),
                ).add_to(map)

            # Add the route as a blue line
            f_group = folium.FeatureGroup("Route overview")
            folium.vector_layers.PolyLine(
                route_coords,
                popup="<b>Overall route</b>",
                tooltip="This is a tooltip where we can add distance and duration",
                color="blue",
                weight=2,
            ).add_to(f_group)
            f_group.add_to(map)
            st.session_state.map = map
        return st.session_state.map

    def show_map():
        map = create_map()
        folium_static(map)

    show_map()
    
with st.form("travel_form"):
   query = st.text_input("Type your travel plan:")
   submitted = st.form_submit_button("Submit")
   if submitted:
       run_test(query)
    